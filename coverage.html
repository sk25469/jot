
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/sk25469/jot/app/app.go (0.0%)</option>
				
				<option value="file1">github.com/sk25469/jot/cmd/list.go (4.5%)</option>
				
				<option value="file2">github.com/sk25469/jot/cmd/new.go (18.2%)</option>
				
				<option value="file3">github.com/sk25469/jot/cmd/open.go (0.0%)</option>
				
				<option value="file4">github.com/sk25469/jot/cmd/root.go (41.7%)</option>
				
				<option value="file5">github.com/sk25469/jot/cmd/search.go (0.0%)</option>
				
				<option value="file6">github.com/sk25469/jot/cmd/stats.go (0.0%)</option>
				
				<option value="file7">github.com/sk25469/jot/config/config.go (23.5%)</option>
				
				<option value="file8">github.com/sk25469/jot/database/database.go (0.0%)</option>
				
				<option value="file9">github.com/sk25469/jot/database/note_repository.go (0.0%)</option>
				
				<option value="file10">github.com/sk25469/jot/database/stats_repository.go (0.0%)</option>
				
				<option value="file11">github.com/sk25469/jot/main.go (0.0%)</option>
				
				<option value="file12">github.com/sk25469/jot/models/models.go (100.0%)</option>
				
				<option value="file13">github.com/sk25469/jot/notes/notes.go (0.0%)</option>
				
				<option value="file14">github.com/sk25469/jot/service/note_service.go (14.4%)</option>
				
				<option value="file15">github.com/sk25469/jot/styles/styles.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package app

import (
        "fmt"
        "path/filepath"

        "github.com/sk25469/jot/config"
        "github.com/sk25469/jot/database"
        "github.com/sk25469/jot/service"
)

// App holds the application dependencies
type App struct {
        DB          *database.DB
        NoteService *service.NoteService
}

// Global app instance
var Instance *App

// Initialize sets up the application with database and services
func Initialize() error <span class="cov0" title="0">{
        // Initialize config first
        if err := config.InitConfig(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize config: %w", err)
        }</span>

        // Initialize database
        <span class="cov0" title="0">dbPath := filepath.Join(config.GetJotDir(), "jot.db")
        db, err := database.New(database.Config{
                Path: dbPath,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize database: %w", err)
        }</span>

        // Initialize services
        <span class="cov0" title="0">noteService := service.NewNoteService(db)

        // Sync existing notes from filesystem to database
        if err := noteService.SyncFromFileSystem(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to sync notes from filesystem: %w", err)
        }</span>

        // Set global instance
        <span class="cov0" title="0">Instance = &amp;App{
                DB:          db,
                NoteService: noteService,
        }

        return nil</span>
}

// Cleanup closes database connections and performs cleanup
func Cleanup() error <span class="cov0" title="0">{
        if Instance != nil &amp;&amp; Instance.DB != nil </span><span class="cov0" title="0">{
                return Instance.DB.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetJotDir returns the jot directory path (same as config package function)
func GetJotDir() string <span class="cov0" title="0">{
        return config.GetJotDir()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "fmt"

        "github.com/charmbracelet/lipgloss"
        "github.com/sk25469/jot/app"
        "github.com/sk25469/jot/models"
        "github.com/sk25469/jot/styles"
        "github.com/spf13/cobra"
)

var listCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List all notes",
        Long:  `List all notes with optional filtering by tag and mode.`,
        RunE:  runListCommand,
}

func runListCommand(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        tagFilter, _ := cmd.Flags().GetString("tag")
        modeFilter, _ := cmd.Flags().GetString("mode")

        notesList, err := app.Instance.NoteService.ListNotes(tagFilter, modeFilter)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(notesList) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No notes found.")
                return nil
        }</span>

        <span class="cov0" title="0">printNotesList(notesList)
        return nil</span>
}

func printNotesList(notesList []*models.Note) <span class="cov0" title="0">{
        if len(notesList) == 0 </span><span class="cov0" title="0">{
                fmt.Println(styles.WarningStyle.Render("No notes found."))
                return
        }</span>

        // Print beautiful header
        <span class="cov0" title="0">header := styles.RenderHeader(fmt.Sprintf("Notes (%d)", len(notesList)))
        fmt.Println(header)
        fmt.Println()

        // Create a table-like layout using lipgloss
        for i, note := range notesList </span><span class="cov0" title="0">{
                // Create the main note entry
                noteEntry := createNoteEntry(note)
                fmt.Println(noteEntry)

                // Add spacing between notes, but not after the last one
                if i &lt; len(notesList)-1 </span><span class="cov0" title="0">{
                        fmt.Println()
                }</span>
        }

        // Footer with total count
        <span class="cov0" title="0">fmt.Println()
        fmt.Println(styles.RenderSeparator())
        totalText := fmt.Sprintf("Total: %d notes", len(notesList))
        fmt.Println(styles.StatsLabelStyle.Render(totalText))</span>
}

func createNoteEntry(note *models.Note) string <span class="cov0" title="0">{
        // Format the ID with style
        idText := styles.IDStyle.Render(note.ID)

        // Format the date
        dateText := styles.DateStyle.Render(note.CreatedAt.Format("2006-01-02"))

        // Format the title
        title := note.Title
        if len(title) &gt; 50 </span><span class="cov0" title="0">{
                title = title[:47] + "..."
        }</span>
        <span class="cov0" title="0">titleText := styles.ContentStyle.Render(title)

        // Format the mode badge
        modeText := styles.GetModeStyle(note.Mode).Render(note.Mode)

        // Format tags with colors
        tagsText := ""
        if len(note.Tags) &gt; 0 </span><span class="cov0" title="0">{
                tagsText = styles.RenderTags(note.Tags)
        }</span> else<span class="cov0" title="0"> {
                tagsText = lipgloss.NewStyle().Foreground(styles.Subtle).Render("no tags")
        }</span>

        // Create the first line with ID, date, and title
        <span class="cov0" title="0">firstLine := lipgloss.JoinHorizontal(
                lipgloss.Left,
                idText,
                "  ",
                dateText,
                "  ",
                modeText,
                "  ",
                titleText,
        )

        // Create the second line with tags (indented)
        secondLine := lipgloss.NewStyle().
                MarginLeft(2).
                Render("tags: " + tagsText)

        // Combine both lines
        return lipgloss.JoinVertical(
                lipgloss.Left,
                firstLine,
                secondLine,
        )</span>
}

func formatNoteTitle(title string) string <span class="cov0" title="0">{
        if len(title) &gt; 30 </span><span class="cov0" title="0">{
                return title[:27] + "..."
        }</span>
        <span class="cov0" title="0">return title</span>
}

func init() <span class="cov8" title="1">{
        listCmd.Flags().StringP("tag", "t", "", "Filter by tag")
        listCmd.Flags().StringP("mode", "m", "", "Filter by mode")
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "strings"

        "github.com/sk25469/jot/app"
        "github.com/spf13/cobra"
)

var newCmd = &amp;cobra.Command{
        Use:   "new [title]",
        Short: "Create a new note",
        Long:  `Create a new markdown note with optional title, tags, and mode.`,
        Args:  cobra.ArbitraryArgs,
        RunE:  runNewCommand,
}

func runNewCommand(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        title := getNoteTitleFromArgs(args)
        tags, _ := cmd.Flags().GetStringSlice("tag")
        mode, _ := cmd.Flags().GetString("mode")

        _, err := app.Instance.NoteService.CreateNote(title, tags, mode)
        return err
}</span>

func getNoteTitleFromArgs(args []string) string <span class="cov0" title="0">{
        title := strings.Join(args, " ")
        if title == "" </span><span class="cov0" title="0">{
                title = "Untitled"
        }</span>
        <span class="cov0" title="0">return title</span>
}

func init() <span class="cov8" title="1">{
        newCmd.Flags().StringSliceP("tag", "t", []string{}, "Tags for the note")
        newCmd.Flags().StringP("mode", "m", "", "Mode for the note (defaults to config default)")
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package cmd

import (
        "strings"

        "github.com/sk25469/jot/app"
        "github.com/spf13/cobra"
)

var openCmd = &amp;cobra.Command{
        Use:   "open &lt;id or title&gt;",
        Short: "Open a note in your editor",
        Long:  `Open a note by ID or partial title match in your configured editor.`,
        Args:  cobra.MinimumNArgs(1),
        RunE:  runOpenCommand,
}

func runOpenCommand(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        identifier := strings.Join(args, " ")
        return app.Instance.NoteService.OpenNote(identifier)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package cmd

import (
        "fmt"
        "os"

        "github.com/sk25469/jot/app"
        "github.com/sk25469/jot/styles"
        "github.com/spf13/cobra"
)

var rootCmd = &amp;cobra.Command{
        Use:   "jot",
        Short: "A lightning-fast terminal-based note-taking and journaling CLI",
        Long: `jot is a terminal-based note-taking CLI that feels like git and fzf had a baby.
It provides lightning-fast capture and recall of thoughts, code, or reflections
without ever leaving the terminal.

All notes are stored as plain markdown files in ~/.jot/notes/`,
        PersistentPreRunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return app.Initialize()
        }</span>,
        PersistentPostRunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return app.Cleanup()
        }</span>,
}

func Execute() error <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                errorMsg := styles.ErrorStyle.Render(fmt.Sprintf("Error: %v", err))
                fmt.Fprintf(os.Stderr, "%s\n", errorMsg)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(newCmd)
        rootCmd.AddCommand(listCmd)
        rootCmd.AddCommand(searchCmd)
        rootCmd.AddCommand(openCmd)
        rootCmd.AddCommand(statsCmd)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package cmd

import (
        "fmt"
        "strings"

        "github.com/charmbracelet/lipgloss"
        "github.com/sk25469/jot/app"
        "github.com/sk25469/jot/models"
        "github.com/sk25469/jot/styles"
        "github.com/spf13/cobra"
)

var searchCmd = &amp;cobra.Command{
        Use:   "search &lt;query&gt;",
        Short: "Search notes",
        Long:  `Search notes by title, content, or tags using fuzzy matching.`,
        Args:  cobra.MinimumNArgs(1),
        RunE:  runSearchCommand,
}

func runSearchCommand(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        query := strings.Join(args, " ")

        results, err := app.Instance.NoteService.SearchNotes(query)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(results) == 0 </span><span class="cov0" title="0">{
                noResultsMsg := fmt.Sprintf("No notes found matching: %s", query)
                fmt.Println(styles.WarningStyle.Render(noResultsMsg))
                return nil
        }</span>

        <span class="cov0" title="0">printSearchResults(results, query)
        return nil</span>
}

func printSearchResults(results []*models.SearchResult, query string) <span class="cov0" title="0">{
        // Beautiful header with search query
        header := styles.RenderHeader(fmt.Sprintf("Search Results (%d)", len(results)))
        queryText := lipgloss.NewStyle().
                Foreground(styles.Warning).
                Bold(true).
                Render(fmt.Sprintf("Query: \"%s\"", query))

        fmt.Println(header)
        fmt.Println(queryText)
        fmt.Println()

        for i, result := range results </span><span class="cov0" title="0">{
                // Create styled search result entry
                searchEntry := createSearchResultEntry(result, i+1)
                fmt.Println(searchEntry)

                // Add spacing between results
                if i &lt; len(results)-1 </span><span class="cov0" title="0">{
                        fmt.Println()
                }</span>
        }

        // Footer
        <span class="cov0" title="0">fmt.Println()
        fmt.Println(styles.RenderSeparator())
        totalText := fmt.Sprintf("Found %d matches", len(results))
        fmt.Println(styles.StatsLabelStyle.Render(totalText))</span>
}

func createSearchResultEntry(result *models.SearchResult, index int) string <span class="cov0" title="0">{
        // Rank indicator
        rankText := lipgloss.NewStyle().
                Foreground(styles.Primary).
                Bold(true).
                Render(fmt.Sprintf("#%d", index))

        // ID and date
        idText := styles.IDStyle.Render(result.ID)
        dateText := styles.DateStyle.Render(result.CreatedAt.Format("2006-01-02"))

        // Title with highlighting potential
        titleText := styles.ContentStyle.Bold(true).Render(result.Title)

        // Mode badge
        modeText := styles.GetModeStyle(result.Mode).Render(result.Mode)

        // Relevance score (if available)
        scoreText := ""
        if result.Rank &gt; 0 </span><span class="cov0" title="0">{
                score := fmt.Sprintf("%.2f", result.Rank)
                scoreText = lipgloss.NewStyle().
                        Foreground(styles.Accent).
                        Render(fmt.Sprintf("score: %s", score))
        }</span>

        // First line: rank, ID, date, mode, title
        <span class="cov0" title="0">firstLine := lipgloss.JoinHorizontal(
                lipgloss.Left,
                rankText,
                "  ",
                idText,
                "  ",
                dateText,
                "  ",
                modeText,
                "  ",
                titleText,
        )

        if scoreText != "" </span><span class="cov0" title="0">{
                firstLine = lipgloss.JoinHorizontal(
                        lipgloss.Left,
                        firstLine,
                        "  ",
                        scoreText,
                )
        }</span>

        // Second line: tags
        <span class="cov0" title="0">secondLine := ""
        if len(result.Tags) &gt; 0 </span><span class="cov0" title="0">{
                tagsText := styles.RenderTags(result.Tags)
                secondLine = lipgloss.NewStyle().
                        MarginLeft(4).
                        Render("tags: " + tagsText)
        }</span>

        // Third line: snippet (if available)
        <span class="cov0" title="0">thirdLine := ""
        if result.Snippet != "" &amp;&amp; result.Snippet != result.Title </span><span class="cov0" title="0">{
                snippetText := result.Snippet
                if len(snippetText) &gt; 100 </span><span class="cov0" title="0">{
                        snippetText = snippetText[:97] + "..."
                }</span>
                <span class="cov0" title="0">thirdLine = lipgloss.NewStyle().
                        MarginLeft(4).
                        Foreground(styles.Muted).
                        Italic(true).
                        Render("\"" + snippetText + "\"")</span>
        }

        // Combine all lines
        <span class="cov0" title="0">lines := []string{firstLine}
        if secondLine != "" </span><span class="cov0" title="0">{
                lines = append(lines, secondLine)
        }</span>
        <span class="cov0" title="0">if thirdLine != "" </span><span class="cov0" title="0">{
                lines = append(lines, thirdLine)
        }</span>

        <span class="cov0" title="0">return lipgloss.JoinVertical(lipgloss.Left, lines...)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package cmd

import (
        "fmt"
        "sort"

        "github.com/charmbracelet/lipgloss"
        "github.com/sk25469/jot/app"
        "github.com/sk25469/jot/models"
        "github.com/sk25469/jot/styles"
        "github.com/spf13/cobra"
)

var statsCmd = &amp;cobra.Command{
        Use:   "stats",
        Short: "Show note statistics",
        Long:  `Display statistics about your notes including total count, weekly activity, and popular tags.`,
        RunE:  runStatsCommand,
}

func runStatsCommand(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        stats, err := app.Instance.NoteService.GetStats()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">printNoteStatistics(stats)
        return nil</span>
}

func printNoteStatistics(stats *models.StatsResult) <span class="cov0" title="0">{
        // Beautiful header
        header := styles.RenderHeader("Statistics")
        fmt.Println(header)

        // Create main stats section
        mainStats := createMainStatsSection(stats)
        fmt.Println(mainStats)
        fmt.Println()

        // Tags section
        if len(stats.TagCounts) &gt; 0 </span><span class="cov0" title="0">{
                tagsSection := createTagsSection(stats.TagCounts)
                fmt.Println(tagsSection)
                fmt.Println()
        }</span>

        // Modes section
        <span class="cov0" title="0">if len(stats.ModeStats) &gt; 0 </span><span class="cov0" title="0">{
                modesSection := createModesSection(stats.ModeStats)
                fmt.Println(modesSection)
        }</span>
}

func createMainStatsSection(stats *models.StatsResult) string <span class="cov0" title="0">{
        // Create formatted stat entries
        totalText := fmt.Sprintf("%s %s",
                styles.StatsLabelStyle.Render("Total notes:"),
                styles.StatsValueStyle.Render(fmt.Sprintf("%d", stats.TotalNotes)))

        weeklyText := fmt.Sprintf("%s %s",
                styles.StatsLabelStyle.Render("This week:"),
                styles.StatsValueStyle.Render(fmt.Sprintf("%d", stats.NotesThisWeek)))

        todayText := fmt.Sprintf("%s %s",
                styles.StatsLabelStyle.Render("Created today:"),
                styles.StatsValueStyle.Render(fmt.Sprintf("%d", stats.CreatedToday)))

        wordsText := fmt.Sprintf("%s %s",
                styles.StatsLabelStyle.Render("Total words:"),
                styles.StatsValueStyle.Render(fmt.Sprintf("%d", stats.WordCount)))

        // Progress bar for weekly activity
        progressBar := ""
        if stats.TotalNotes &gt; 0 </span><span class="cov0" title="0">{
                progressBar = styles.RenderProgress(stats.NotesThisWeek, 10) // Assuming target of 10 notes per week
        }</span>

        // Combine all stats
        <span class="cov0" title="0">statsContent := lipgloss.JoinVertical(
                lipgloss.Left,
                totalText,
                weeklyText,
                todayText,
                wordsText,
        )

        if progressBar != "" </span><span class="cov0" title="0">{
                statsContent = lipgloss.JoinVertical(
                        lipgloss.Left,
                        statsContent,
                        "",
                        lipgloss.NewStyle().Foreground(styles.Subtle).Render("Weekly Activity:"),
                        progressBar,
                )
        }</span>

        <span class="cov0" title="0">return styles.RenderBox("📊 Overview", statsContent)</span>
}

func createTagsSection(tagCounts map[string]int) string <span class="cov0" title="0">{
        // Sort tags by count
        type tagCount struct {
                tag   string
                count int
        }
        var tagList []tagCount
        for tag, count := range tagCounts </span><span class="cov0" title="0">{
                tagList = append(tagList, tagCount{tag, count})
        }</span>
        <span class="cov0" title="0">sort.Slice(tagList, func(i, j int) bool </span><span class="cov0" title="0">{
                return tagList[i].count &gt; tagList[j].count
        }</span>)

        // Create styled tag entries
        <span class="cov0" title="0">var tagEntries []string
        limit := 8 // Show top 8 tags
        if len(tagList) &lt; limit </span><span class="cov0" title="0">{
                limit = len(tagList)
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; limit; i++ </span><span class="cov0" title="0">{
                tag := tagList[i]
                tagStyle := styles.GetTagStyle(tag.tag)
                countStyle := styles.StatsValueStyle

                entry := lipgloss.JoinHorizontal(
                        lipgloss.Left,
                        tagStyle.Render(tag.tag),
                        "  ",
                        countStyle.Render(fmt.Sprintf("(%d)", tag.count)),
                )
                tagEntries = append(tagEntries, entry)
        }</span>

        // Arrange tags in a grid (2 columns)
        <span class="cov0" title="0">var rows []string
        for i := 0; i &lt; len(tagEntries); i += 2 </span><span class="cov0" title="0">{
                if i+1 &lt; len(tagEntries) </span><span class="cov0" title="0">{
                        row := lipgloss.JoinHorizontal(
                                lipgloss.Left,
                                tagEntries[i],
                                "    ", // Spacing between columns
                                tagEntries[i+1],
                        )
                        rows = append(rows, row)
                }</span> else<span class="cov0" title="0"> {
                        rows = append(rows, tagEntries[i])
                }</span>
        }

        <span class="cov0" title="0">tagsContent := lipgloss.JoinVertical(lipgloss.Left, rows...)
        return styles.RenderBox("🏷️  Popular Tags", tagsContent)</span>
}

func createModesSection(modeStats map[string]int) string <span class="cov0" title="0">{
        var modeEntries []string

        for mode, count := range modeStats </span><span class="cov0" title="0">{
                modeStyle := styles.GetModeStyle(mode)
                countStyle := styles.StatsValueStyle

                entry := lipgloss.JoinHorizontal(
                        lipgloss.Left,
                        modeStyle.Render(mode),
                        "  ",
                        countStyle.Render(fmt.Sprintf("(%d)", count)),
                )
                modeEntries = append(modeEntries, entry)
        }</span>

        <span class="cov0" title="0">modesContent := lipgloss.JoinVertical(lipgloss.Left, modeEntries...)
        return styles.RenderBox("📝 Note Modes", modesContent)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package config

import (
        "os"
        "path/filepath"

        "github.com/spf13/viper"
)

type Config struct {
        Editor      string `mapstructure:"editor"`
        DefaultMode string `mapstructure:"default_mode"`
        StoragePath string `mapstructure:"storage_path"`
}

var AppConfig Config

func InitConfig() error <span class="cov0" title="0">{
        // Set default values
        viper.SetDefault("editor", getDefaultEditor())
        viper.SetDefault("default_mode", "dev")
        viper.SetDefault("storage_path", getDefaultStoragePath())

        // Config file settings
        viper.SetConfigName("config")
        viper.SetConfigType("yaml")
        viper.AddConfigPath(getJotDir())

        // Create jot directory if it doesn't exist
        jotDir := getJotDir()
        if err := os.MkdirAll(jotDir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create notes directory if it doesn't exist
        <span class="cov0" title="0">notesDir := filepath.Join(jotDir, "notes")
        if err := os.MkdirAll(notesDir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Read config file if it exists
        <span class="cov0" title="0">if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                // Config file not found, create a default one
                if _, ok := err.(viper.ConfigFileNotFoundError); ok </span><span class="cov0" title="0">{
                        if err := createDefaultConfig(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        return err
                }</span>
        }

        // Unmarshal config into struct
        <span class="cov0" title="0">if err := viper.Unmarshal(&amp;AppConfig); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Expand storage path if it contains ~
        <span class="cov0" title="0">if AppConfig.StoragePath[:2] == "~/" </span><span class="cov0" title="0">{
                homeDir, _ := os.UserHomeDir()
                AppConfig.StoragePath = filepath.Join(homeDir, AppConfig.StoragePath[2:])
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func getJotDir() string <span class="cov8" title="1">{
        homeDir, _ := os.UserHomeDir()
        return filepath.Join(homeDir, ".jot")
}</span>

func getDefaultStoragePath() string <span class="cov8" title="1">{
        return filepath.Join(getJotDir(), "notes")
}</span>

func getDefaultEditor() string <span class="cov8" title="1">{
        if editor := os.Getenv("EDITOR"); editor != "" </span><span class="cov8" title="1">{
                return editor
        }</span>
        <span class="cov8" title="1">return "vim"</span>
}

func createDefaultConfig() error <span class="cov0" title="0">{
        configPath := filepath.Join(getJotDir(), "config.yaml")

        defaultConfig := `editor: "` + getDefaultEditor() + `"
default_mode: "dev"
storage_path: "` + getDefaultStoragePath() + `"
`

        return os.WriteFile(configPath, []byte(defaultConfig), 0644)
}</span>

func GetNotesDir() string <span class="cov8" title="1">{
        return AppConfig.StoragePath
}</span>

func GetJotDir() string <span class="cov8" title="1">{
        return getJotDir()
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package database

import (
        "database/sql"
        "embed"
        "fmt"
        "os"
        "path/filepath"

        _ "modernc.org/sqlite"
)

//go:embed schema.sql
var schemaFS embed.FS

// DB represents the application database
type DB struct {
        conn *sql.DB
        path string
}

// Config holds database configuration
type Config struct {
        Path string
}

// New creates a new database connection
func New(config Config) (*DB, error) <span class="cov0" title="0">{
        // Ensure database directory exists
        dbDir := filepath.Dir(config.Path)
        if err := os.MkdirAll(dbDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create database directory: %w", err)
        }</span>

        // Open database connection
        <span class="cov0" title="0">conn, err := sql.Open("sqlite", config.Path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        // Configure SQLite for optimal performance
        <span class="cov0" title="0">if err := configureSQLite(conn); err != nil </span><span class="cov0" title="0">{
                conn.Close()
                return nil, fmt.Errorf("failed to configure SQLite: %w", err)
        }</span>

        <span class="cov0" title="0">db := &amp;DB{
                conn: conn,
                path: config.Path,
        }

        // Initialize schema if needed
        if err := db.initializeSchema(); err != nil </span><span class="cov0" title="0">{
                conn.Close()
                return nil, fmt.Errorf("failed to initialize schema: %w", err)
        }</span>

        <span class="cov0" title="0">return db, nil</span>
}

// Close closes the database connection
func (db *DB) Close() error <span class="cov0" title="0">{
        if db.conn != nil </span><span class="cov0" title="0">{
                return db.conn.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Connection returns the underlying sql.DB connection
func (db *DB) Connection() *sql.DB <span class="cov0" title="0">{
        return db.conn
}</span>

// configureSQLite sets up SQLite for optimal performance
func configureSQLite(conn *sql.DB) error <span class="cov0" title="0">{
        pragmas := []string{
                "PRAGMA foreign_keys = ON",
                "PRAGMA journal_mode = WAL",
                "PRAGMA synchronous = NORMAL",
                "PRAGMA cache_size = -64000", // 64MB cache
                "PRAGMA temp_store = MEMORY",
                "PRAGMA mmap_size = 268435456", // 256MB mmap
        }

        for _, pragma := range pragmas </span><span class="cov0" title="0">{
                if _, err := conn.Exec(pragma); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to execute pragma %s: %w", pragma, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// initializeSchema creates tables if they don't exist
func (db *DB) initializeSchema() error <span class="cov0" title="0">{
        // Check if database is already initialized
        var count int
        err := db.conn.QueryRow("SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='notes'").Scan(&amp;count)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check if schema exists: %w", err)
        }</span>

        // If tables exist, check version and potentially migrate
        <span class="cov0" title="0">if count &gt; 0 </span><span class="cov0" title="0">{
                return db.checkAndMigrate()
        }</span>

        // Read schema from embedded file
        <span class="cov0" title="0">schemaBytes, err := schemaFS.ReadFile("schema.sql")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read embedded schema: %w", err)
        }</span>

        // Execute schema
        <span class="cov0" title="0">if _, err := db.conn.Exec(string(schemaBytes)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute schema: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// checkAndMigrate checks the database version and runs migrations if needed
func (db *DB) checkAndMigrate() error <span class="cov0" title="0">{
        var version string
        err := db.conn.QueryRow("SELECT value FROM config WHERE key = 'db_version'").Scan(&amp;version)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get database version: %w", err)
        }</span>

        // For now, we assume version 1.0 is current
        // Future migrations would go here
        <span class="cov0" title="0">if version == "" </span><span class="cov0" title="0">{
                // Insert version if missing
                _, err = db.conn.Exec("INSERT OR REPLACE INTO config (key, value) VALUES ('db_version', '1.0')")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set database version: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "strings"
        "time"

        "github.com/sk25469/jot/models"
)

// NoteRepository handles database operations for notes
type NoteRepository struct {
        db *DB
}

// NewNoteRepository creates a new note repository
func NewNoteRepository(db *DB) *NoteRepository <span class="cov0" title="0">{
        return &amp;NoteRepository{db: db}
}</span>

// GetDB returns the underlying database connection
func (r *NoteRepository) GetDB() *DB <span class="cov0" title="0">{
        return r.db
}</span>

// Create creates a new note in the database
func (r *NoteRepository) Create(note *models.Note) error <span class="cov0" title="0">{
        tx, err := r.db.conn.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Insert note
        query := `
                INSERT INTO notes (id, title, mode, file_path, file_name, content_hash, 
                        created_at, updated_at, content_preview, word_count)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`

        _, err = tx.Exec(query,
                note.ID, note.Title, note.Mode, note.FilePath, note.FileName,
                note.ContentHash, note.CreatedAt, note.UpdatedAt,
                note.ContentPreview, note.WordCount)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert note: %w", err)
        }</span>

        // Insert tags if any
        <span class="cov0" title="0">if len(note.Tags) &gt; 0 </span><span class="cov0" title="0">{
                if err := r.insertTagsForNote(tx, note.ID, note.Tags); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to insert tags: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return tx.Commit()</span>
}

// Update updates an existing note
func (r *NoteRepository) Update(note *models.Note) error <span class="cov0" title="0">{
        tx, err := r.db.conn.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Update note
        query := `
                UPDATE notes 
                SET title = ?, mode = ?, content_hash = ?, updated_at = ?, 
                        content_preview = ?, word_count = ?
                WHERE id = ?`

        _, err = tx.Exec(query,
                note.Title, note.Mode, note.ContentHash, note.UpdatedAt,
                note.ContentPreview, note.WordCount, note.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update note: %w", err)
        }</span>

        // Update tags - delete existing and insert new ones
        <span class="cov0" title="0">if _, err := tx.Exec("DELETE FROM note_tags WHERE note_id = ?", note.ID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete existing tags: %w", err)
        }</span>

        <span class="cov0" title="0">if len(note.Tags) &gt; 0 </span><span class="cov0" title="0">{
                if err := r.insertTagsForNote(tx, note.ID, note.Tags); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to insert updated tags: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return tx.Commit()</span>
}

// GetByID retrieves a note by its ID
func (r *NoteRepository) GetByID(id string) (*models.Note, error) <span class="cov0" title="0">{
        query := `
                SELECT n.id, n.title, n.mode, n.file_path, n.file_name, n.content_hash,
                        n.created_at, n.updated_at, n.content_preview, n.word_count,
                        COALESCE(GROUP_CONCAT(t.name, ','), '') as tags
                FROM notes n
                LEFT JOIN note_tags nt ON n.id = nt.note_id
                LEFT JOIN tags t ON nt.tag_id = t.id
                WHERE n.id = ?
                GROUP BY n.id`

        row := r.db.conn.QueryRow(query, id)

        note := &amp;models.Note{}
        var tagsStr string

        err := row.Scan(
                &amp;note.ID, &amp;note.Title, &amp;note.Mode, &amp;note.FilePath, &amp;note.FileName,
                &amp;note.ContentHash, &amp;note.CreatedAt, &amp;note.UpdatedAt,
                &amp;note.ContentPreview, &amp;note.WordCount, &amp;tagsStr)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get note by ID: %w", err)</span>
        }

        // Parse tags
        <span class="cov0" title="0">if tagsStr != "" </span><span class="cov0" title="0">{
                note.Tags = strings.Split(tagsStr, ",")
        }</span>

        <span class="cov0" title="0">return note, nil</span>
}

// List retrieves notes with optional filtering
func (r *NoteRepository) List(filter models.ListFilter) ([]*models.Note, error) <span class="cov0" title="0">{
        query := `
                SELECT n.id, n.title, n.mode, n.file_path, n.file_name, n.content_hash,
                        n.created_at, n.updated_at, n.content_preview, n.word_count,
                        COALESCE(GROUP_CONCAT(t.name, ','), '') as tags
                FROM notes n
                LEFT JOIN note_tags nt ON n.id = nt.note_id
                LEFT JOIN tags t ON nt.tag_id = t.id`

        var conditions []string
        var args []interface{}

        // Build WHERE clause
        if filter.Mode != "" </span><span class="cov0" title="0">{
                conditions = append(conditions, "n.mode = ?")
                args = append(args, filter.Mode)
        }</span>

        <span class="cov0" title="0">if filter.Since != nil </span><span class="cov0" title="0">{
                conditions = append(conditions, "n.created_at &gt;= ?")
                args = append(args, filter.Since)
        }</span>

        <span class="cov0" title="0">if filter.Until != nil </span><span class="cov0" title="0">{
                conditions = append(conditions, "n.created_at &lt;= ?")
                args = append(args, filter.Until)
        }</span>

        // Handle tag filtering
        <span class="cov0" title="0">if len(filter.Tags) &gt; 0 </span><span class="cov0" title="0">{
                tagPlaceholders := strings.Repeat("?,", len(filter.Tags)-1) + "?"
                conditions = append(conditions, fmt.Sprintf(`n.id IN (
                        SELECT nt.note_id FROM note_tags nt 
                        JOIN tags t ON nt.tag_id = t.id 
                        WHERE t.name IN (%s))`, tagPlaceholders))
                for _, tag := range filter.Tags </span><span class="cov0" title="0">{
                        args = append(args, tag)
                }</span>
        }

        <span class="cov0" title="0">if len(conditions) &gt; 0 </span><span class="cov0" title="0">{
                query += " WHERE " + strings.Join(conditions, " AND ")
        }</span>

        <span class="cov0" title="0">query += " GROUP BY n.id"

        // Add sorting
        sortColumn := "n.created_at"
        switch filter.SortBy </span>{
        case "updated":<span class="cov0" title="0">
                sortColumn = "n.updated_at"</span>
        case "title":<span class="cov0" title="0">
                sortColumn = "n.title"</span>
        }

        <span class="cov0" title="0">sortOrder := "DESC"
        if filter.SortOrder == "asc" </span><span class="cov0" title="0">{
                sortOrder = "ASC"
        }</span>

        <span class="cov0" title="0">query += fmt.Sprintf(" ORDER BY %s %s", sortColumn, sortOrder)

        // Add pagination
        if filter.Limit &gt; 0 </span><span class="cov0" title="0">{
                query += " LIMIT ?"
                args = append(args, filter.Limit)

                if filter.Offset &gt; 0 </span><span class="cov0" title="0">{
                        query += " OFFSET ?"
                        args = append(args, filter.Offset)
                }</span>
        }

        <span class="cov0" title="0">rows, err := r.db.conn.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list notes: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var notes []*models.Note
        for rows.Next() </span><span class="cov0" title="0">{
                note := &amp;models.Note{}
                var tagsStr string

                err := rows.Scan(
                        &amp;note.ID, &amp;note.Title, &amp;note.Mode, &amp;note.FilePath, &amp;note.FileName,
                        &amp;note.ContentHash, &amp;note.CreatedAt, &amp;note.UpdatedAt,
                        &amp;note.ContentPreview, &amp;note.WordCount, &amp;tagsStr)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan note: %w", err)
                }</span>

                // Parse tags
                <span class="cov0" title="0">if tagsStr != "" </span><span class="cov0" title="0">{
                        note.Tags = strings.Split(tagsStr, ",")
                }</span>

                <span class="cov0" title="0">notes = append(notes, note)</span>
        }

        <span class="cov0" title="0">return notes, nil</span>
}

// Search performs full-text search on notes
func (r *NoteRepository) Search(query string) ([]*models.SearchResult, error) <span class="cov0" title="0">{
        searchQuery := `
                SELECT n.id, n.title, n.mode, n.file_path, n.file_name, n.content_hash,
                        n.created_at, n.updated_at, n.content_preview, n.word_count,
                        COALESCE(GROUP_CONCAT(t.name, ','), '') as tags,
                        fts.bm25(fts) as rank, 'fts' as match_type
                FROM notes_fts fts
                JOIN notes n ON fts.note_id = n.id
                LEFT JOIN note_tags nt ON n.id = nt.note_id
                LEFT JOIN tags t ON nt.tag_id = t.id
                WHERE notes_fts MATCH ?
                GROUP BY n.id
                ORDER BY rank ASC`

        rows, err := r.db.conn.Query(searchQuery, query)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to simple LIKE search if FTS fails
                return r.fallbackSearch(query)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var results []*models.SearchResult
        for rows.Next() </span><span class="cov0" title="0">{
                result := &amp;models.SearchResult{}
                var tagsStr string

                err := rows.Scan(
                        &amp;result.ID, &amp;result.Title, &amp;result.Mode, &amp;result.FilePath, &amp;result.FileName,
                        &amp;result.ContentHash, &amp;result.CreatedAt, &amp;result.UpdatedAt,
                        &amp;result.ContentPreview, &amp;result.WordCount, &amp;tagsStr,
                        &amp;result.Rank, &amp;result.MatchType)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan search result: %w", err)
                }</span>

                // Parse tags
                <span class="cov0" title="0">if tagsStr != "" </span><span class="cov0" title="0">{
                        result.Tags = strings.Split(tagsStr, ",")
                }</span>

                // Generate snippet from content preview
                <span class="cov0" title="0">result.Snippet = r.generateSnippet(result.ContentPreview, query)

                results = append(results, result)</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

// generateSnippet creates a search snippet highlighting the query terms
func (r *NoteRepository) generateSnippet(content, query string) string <span class="cov0" title="0">{
        if content == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Simple snippet generation - in a real implementation you might want
        // to find the query terms and show context around them
        <span class="cov0" title="0">if len(content) &lt;= 200 </span><span class="cov0" title="0">{
                return content
        }</span>

        // Try to find the query in the content for context
        <span class="cov0" title="0">queryLower := strings.ToLower(query)
        contentLower := strings.ToLower(content)

        if idx := strings.Index(contentLower, queryLower); idx != -1 </span><span class="cov0" title="0">{
                // Show context around the match
                start := idx - 50
                if start &lt; 0 </span><span class="cov0" title="0">{
                        start = 0
                }</span>
                <span class="cov0" title="0">end := idx + len(query) + 150
                if end &gt; len(content) </span><span class="cov0" title="0">{
                        end = len(content)
                }</span>

                <span class="cov0" title="0">snippet := content[start:end]
                if start &gt; 0 </span><span class="cov0" title="0">{
                        snippet = "..." + snippet
                }</span>
                <span class="cov0" title="0">if end &lt; len(content) </span><span class="cov0" title="0">{
                        snippet = snippet + "..."
                }</span>
                <span class="cov0" title="0">return snippet</span>
        }

        // Fallback to beginning of content
        <span class="cov0" title="0">return content[:200] + "..."</span>
}

// Delete removes a note from the database
func (r *NoteRepository) Delete(id string) error <span class="cov0" title="0">{
        tx, err := r.db.conn.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Delete note (cascades to note_tags due to foreign key)
        _, err = tx.Exec("DELETE FROM notes WHERE id = ?", id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete note: %w", err)
        }</span>

        // Update tag usage counts
        <span class="cov0" title="0">_, err = tx.Exec(`
                UPDATE tags SET usage_count = usage_count - 1 
                WHERE id IN (
                        SELECT tag_id FROM note_tags WHERE note_id = ?
                )`, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update tag usage counts: %w", err)
        }</span>

        <span class="cov0" title="0">return tx.Commit()</span>
}

// insertTagsForNote handles tag insertion for a note
func (r *NoteRepository) insertTagsForNote(tx *sql.Tx, noteID string, tags []string) error <span class="cov0" title="0">{
        for _, tagName := range tags </span><span class="cov0" title="0">{
                // Get or create tag
                var tagID int
                err := tx.QueryRow("SELECT id FROM tags WHERE name = ?", tagName).Scan(&amp;tagID)

                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        // Create new tag
                        result, err := tx.Exec(
                                "INSERT INTO tags (name, created_at, usage_count) VALUES (?, ?, 1)",
                                tagName, time.Now())
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create tag %s: %w", tagName, err)
                        }</span>

                        <span class="cov0" title="0">id, err := result.LastInsertId()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get tag ID: %w", err)
                        }</span>
                        <span class="cov0" title="0">tagID = int(id)</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to query tag %s: %w", tagName, err)
                }</span> else<span class="cov0" title="0"> {
                        // Update usage count for existing tag
                        _, err = tx.Exec("UPDATE tags SET usage_count = usage_count + 1 WHERE id = ?", tagID)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update tag usage count: %w", err)
                        }</span>
                }

                // Create note-tag relationship
                <span class="cov0" title="0">_, err = tx.Exec("INSERT INTO note_tags (note_id, tag_id) VALUES (?, ?)", noteID, tagID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create note-tag relationship: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// fallbackSearch provides simple LIKE-based search when FTS is not available
func (r *NoteRepository) fallbackSearch(query string) ([]*models.SearchResult, error) <span class="cov0" title="0">{
        searchQuery := `
                SELECT n.id, n.title, n.mode, n.file_path, n.file_name, n.content_hash,
                        n.created_at, n.updated_at, n.content_preview, n.word_count,
                        COALESCE(GROUP_CONCAT(t.name, ','), '') as tags
                FROM notes n
                LEFT JOIN note_tags nt ON n.id = nt.note_id
                LEFT JOIN tags t ON nt.tag_id = t.id
                WHERE n.title LIKE ? OR n.content_preview LIKE ? OR t.name LIKE ?
                GROUP BY n.id
                ORDER BY n.updated_at DESC`

        likeQuery := "%" + query + "%"
        rows, err := r.db.conn.Query(searchQuery, likeQuery, likeQuery, likeQuery)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute fallback search: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var results []*models.SearchResult
        for rows.Next() </span><span class="cov0" title="0">{
                result := &amp;models.SearchResult{}
                var tagsStr string

                err := rows.Scan(
                        &amp;result.ID, &amp;result.Title, &amp;result.Mode, &amp;result.FilePath, &amp;result.FileName,
                        &amp;result.ContentHash, &amp;result.CreatedAt, &amp;result.UpdatedAt,
                        &amp;result.ContentPreview, &amp;result.WordCount, &amp;tagsStr)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan fallback search result: %w", err)
                }</span>

                // Parse tags
                <span class="cov0" title="0">if tagsStr != "" </span><span class="cov0" title="0">{
                        result.Tags = strings.Split(tagsStr, ",")
                }</span>

                <span class="cov0" title="0">result.Rank = 1.0
                result.MatchType = "fallback"
                result.Snippet = result.ContentPreview
                if len(result.Snippet) &gt; 200 </span><span class="cov0" title="0">{
                        result.Snippet = result.Snippet[:200] + "..."
                }</span>

                <span class="cov0" title="0">results = append(results, result)</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package database

import (
        "fmt"
        "strings"
        "time"

        "github.com/sk25469/jot/models"
)

// StatsRepository handles database operations for statistics
type StatsRepository struct {
        db *DB
}

// NewStatsRepository creates a new stats repository
func NewStatsRepository(db *DB) *StatsRepository <span class="cov0" title="0">{
        return &amp;StatsRepository{db: db}
}</span>

// GetStats retrieves comprehensive statistics about notes
func (r *StatsRepository) GetStats() (*models.StatsResult, error) <span class="cov0" title="0">{
        stats := &amp;models.StatsResult{
                TagCounts: make(map[string]int),
                ModeStats: make(map[string]int),
        }

        // Get total notes count
        err := r.db.conn.QueryRow("SELECT COUNT(*) FROM notes").Scan(&amp;stats.TotalNotes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total notes count: %w", err)
        }</span>

        // Get notes created this week
        <span class="cov0" title="0">weekAgo := time.Now().AddDate(0, 0, -7)
        err = r.db.conn.QueryRow(
                "SELECT COUNT(*) FROM notes WHERE created_at &gt;= ?", weekAgo).Scan(&amp;stats.NotesThisWeek)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get notes this week: %w", err)
        }</span>

        // Get notes created today
        <span class="cov0" title="0">today := time.Now().Truncate(24 * time.Hour)
        err = r.db.conn.QueryRow(
                "SELECT COUNT(*) FROM notes WHERE created_at &gt;= ?", today).Scan(&amp;stats.CreatedToday)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get notes created today: %w", err)
        }</span>

        // Get total word count
        <span class="cov0" title="0">err = r.db.conn.QueryRow("SELECT COALESCE(SUM(word_count), 0) FROM notes").Scan(&amp;stats.WordCount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total word count: %w", err)
        }</span>

        // Get tag statistics
        <span class="cov0" title="0">tagRows, err := r.db.conn.Query(`
                SELECT t.name, COUNT(nt.note_id) as usage_count
                FROM tags t
                LEFT JOIN note_tags nt ON t.id = nt.tag_id
                GROUP BY t.id, t.name
                ORDER BY usage_count DESC`)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get tag statistics: %w", err)
        }</span>
        <span class="cov0" title="0">defer tagRows.Close()

        for tagRows.Next() </span><span class="cov0" title="0">{
                var tagName string
                var count int
                if err := tagRows.Scan(&amp;tagName, &amp;count); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan tag stats: %w", err)
                }</span>
                <span class="cov0" title="0">stats.TagCounts[tagName] = count</span>
        }

        // Get mode statistics
        <span class="cov0" title="0">modeRows, err := r.db.conn.Query(`
                SELECT mode, COUNT(*) as count
                FROM notes
                GROUP BY mode
                ORDER BY count DESC`)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get mode statistics: %w", err)
        }</span>
        <span class="cov0" title="0">defer modeRows.Close()

        for modeRows.Next() </span><span class="cov0" title="0">{
                var mode string
                var count int
                if err := modeRows.Scan(&amp;mode, &amp;count); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan mode stats: %w", err)
                }</span>
                <span class="cov0" title="0">stats.ModeStats[mode] = count</span>
        }

        <span class="cov0" title="0">return stats, nil</span>
}

// GetTagUsage returns the most used tags with their counts
func (r *StatsRepository) GetTagUsage(limit int) (map[string]int, error) <span class="cov0" title="0">{
        query := `
                SELECT t.name, COUNT(nt.note_id) as usage_count
                FROM tags t
                LEFT JOIN note_tags nt ON t.id = nt.tag_id
                GROUP BY t.id, t.name
                ORDER BY usage_count DESC`

        if limit &gt; 0 </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" LIMIT %d", limit)
        }</span>

        <span class="cov0" title="0">rows, err := r.db.conn.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get tag usage: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        tagCounts := make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var tagName string
                var count int
                if err := rows.Scan(&amp;tagName, &amp;count); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan tag usage: %w", err)
                }</span>
                <span class="cov0" title="0">tagCounts[tagName] = count</span>
        }

        <span class="cov0" title="0">return tagCounts, nil</span>
}

// GetRecentActivity returns notes created in the last N days
func (r *StatsRepository) GetRecentActivity(days int) ([]*models.Note, error) <span class="cov0" title="0">{
        since := time.Now().AddDate(0, 0, -days)

        query := `
                SELECT n.id, n.title, n.mode, n.file_path, n.file_name, n.content_hash,
                        n.created_at, n.updated_at, n.content_preview, n.word_count,
                        COALESCE(GROUP_CONCAT(t.name, ','), '') as tags
                FROM notes n
                LEFT JOIN note_tags nt ON n.id = nt.note_id
                LEFT JOIN tags t ON nt.tag_id = t.id
                WHERE n.created_at &gt;= ?
                GROUP BY n.id
                ORDER BY n.created_at DESC`

        rows, err := r.db.conn.Query(query, since)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get recent activity: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var notes []*models.Note
        for rows.Next() </span><span class="cov0" title="0">{
                note := &amp;models.Note{}
                var tagsStr string

                err := rows.Scan(
                        &amp;note.ID, &amp;note.Title, &amp;note.Mode, &amp;note.FilePath, &amp;note.FileName,
                        &amp;note.ContentHash, &amp;note.CreatedAt, &amp;note.UpdatedAt,
                        &amp;note.ContentPreview, &amp;note.WordCount, &amp;tagsStr)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan recent note: %w", err)
                }</span>

                <span class="cov0" title="0">if tagsStr != "" </span><span class="cov0" title="0">{
                        note.Tags = strings.Split(tagsStr, ",")
                }</span>

                <span class="cov0" title="0">notes = append(notes, note)</span>
        }

        <span class="cov0" title="0">return notes, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package main

import (
        "fmt"
        "os"

        "github.com/sk25469/jot/cmd"
)

func main() <span class="cov0" title="0">{
        if err := cmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package models

import (
        "time"
)

// Note represents a note in the database
type Note struct {
        ID             string    `db:"id" json:"id"`
        Title          string    `db:"title" json:"title"`
        Mode           string    `db:"mode" json:"mode"`
        FilePath       string    `db:"file_path" json:"file_path"`
        FileName       string    `db:"file_name" json:"file_name"`
        ContentHash    string    `db:"content_hash" json:"content_hash"`
        CreatedAt      time.Time `db:"created_at" json:"created_at"`
        UpdatedAt      time.Time `db:"updated_at" json:"updated_at"`
        ContentPreview string    `db:"content_preview" json:"content_preview"`
        WordCount      int       `db:"word_count" json:"word_count"`
        Tags           []string  `json:"tags"` // Populated by joins, not stored directly
}

// Tag represents a tag in the database
type Tag struct {
        ID         int       `db:"id" json:"id"`
        Name       string    `db:"name" json:"name"`
        CreatedAt  time.Time `db:"created_at" json:"created_at"`
        UsageCount int       `db:"usage_count" json:"usage_count"`
}

// NoteTag represents the many-to-many relationship between notes and tags
type NoteTag struct {
        NoteID string `db:"note_id" json:"note_id"`
        TagID  int    `db:"tag_id" json:"tag_id"`
}

// Config represents a configuration setting
type Config struct {
        Key       string    `db:"key" json:"key"`
        Value     string    `db:"value" json:"value"`
        UpdatedAt time.Time `db:"updated_at" json:"updated_at"`
}

// SearchResult represents a full-text search result
type SearchResult struct {
        Note
        Rank      float64 `json:"rank"`       // Search relevance rank
        Snippet   string  `json:"snippet"`    // Highlighted content snippet
        MatchType string  `json:"match_type"` // "title", "content", "tags"
}

// ListFilter represents filtering options for listing notes
type ListFilter struct {
        Tags      []string
        Mode      string
        Since     *time.Time
        Until     *time.Time
        Limit     int
        Offset    int
        SortBy    string // "created", "updated", "title"
        SortOrder string // "asc", "desc"
}

// DefaultListFilter returns a filter with sensible defaults
func DefaultListFilter() ListFilter <span class="cov8" title="1">{
        return ListFilter{
                Limit:     100,
                Offset:    0,
                SortBy:    "created",
                SortOrder: "desc",
        }
}</span>

// StatsResult represents statistics about notes
type StatsResult struct {
        TotalNotes    int            `json:"total_notes"`
        NotesThisWeek int            `json:"notes_this_week"`
        TagCounts     map[string]int `json:"tag_counts"`
        ModeStats     map[string]int `json:"mode_stats"`
        WordCount     int            `json:"word_count"`
        CreatedToday  int            `json:"created_today"`
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package notes

import (
        "crypto/sha1"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "sort"
        "strings"
        "time"

        "github.com/sk25469/jot/config"
)

type Note struct {
        ID       string
        Title    string
        Tags     []string
        Mode     string
        Date     time.Time
        FilePath string
        Content  string
}

// CreateNote creates a new note with the given title and options
func CreateNote(title string, tags []string, mode string) (*Note, error) <span class="cov0" title="0">{
        if mode == "" </span><span class="cov0" title="0">{
                mode = config.AppConfig.DefaultMode
        }</span>

        // Generate timestamp-based filename
        <span class="cov0" title="0">timestamp := time.Now().UTC().Format("2006-01-02T15-04-05Z")
        slug := slugify(title)
        filename := fmt.Sprintf("%s-%s.md", timestamp, slug)

        notesDir := config.GetNotesDir()
        filePath := filepath.Join(notesDir, filename)

        // Create note metadata
        note := &amp;Note{
                ID:       timestamp,
                Title:    title,
                Tags:     tags,
                Mode:     mode,
                Date:     time.Now().UTC(),
                FilePath: filePath,
        }

        // Create note content with metadata header
        content := generateNoteContent(note)

        // Write file
        if err := os.WriteFile(filePath, []byte(content), 0644); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Open in editor
        <span class="cov0" title="0">if err := openInEditor(filePath); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return note, nil</span>
}

// ListNotes returns all notes, optionally filtered by tag and mode
func ListNotes(tagFilter, modeFilter string) ([]*Note, error) <span class="cov0" title="0">{
        notesDir := config.GetNotesDir()

        files, err := filepath.Glob(filepath.Join(notesDir, "*.md"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var notes []*Note
        for _, file := range files </span><span class="cov0" title="0">{
                note, err := parseNoteFile(file)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid files
                }

                // Apply filters
                <span class="cov0" title="0">if tagFilter != "" &amp;&amp; !contains(note.Tags, tagFilter) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if modeFilter != "" &amp;&amp; note.Mode != modeFilter </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">notes = append(notes, note)</span>
        }

        // Sort by date (newest first)
        <span class="cov0" title="0">sort.Slice(notes, func(i, j int) bool </span><span class="cov0" title="0">{
                return notes[i].Date.After(notes[j].Date)
        }</span>)

        <span class="cov0" title="0">return notes, nil</span>
}

// SearchNotes searches for notes by query string
func SearchNotes(query string) ([]*Note, error) <span class="cov0" title="0">{
        notes, err := ListNotes("", "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">query = strings.ToLower(query)
        var matches []*Note

        for _, note := range notes </span><span class="cov0" title="0">{
                // Search in title
                if strings.Contains(strings.ToLower(note.Title), query) </span><span class="cov0" title="0">{
                        matches = append(matches, note)
                        continue</span>
                }

                // Search in tags
                <span class="cov0" title="0">for _, tag := range note.Tags </span><span class="cov0" title="0">{
                        if strings.Contains(strings.ToLower(tag), query) </span><span class="cov0" title="0">{
                                matches = append(matches, note)
                                break</span>
                        }
                }

                // Search in content
                <span class="cov0" title="0">if note.Content != "" &amp;&amp; strings.Contains(strings.ToLower(note.Content), query) </span><span class="cov0" title="0">{
                        matches = append(matches, note)
                }</span>
        }

        <span class="cov0" title="0">return matches, nil</span>
}

// OpenNote opens a note by ID or title
func OpenNote(identifier string) error <span class="cov0" title="0">{
        notes, err := ListNotes("", "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var targetNote *Note

        // Try to find by exact ID first
        for _, note := range notes </span><span class="cov0" title="0">{
                if note.ID == identifier </span><span class="cov0" title="0">{
                        targetNote = note
                        break</span>
                }
        }

        // If not found by exact ID, try partial ID match (like git)
        <span class="cov0" title="0">if targetNote == nil </span><span class="cov0" title="0">{
                matches := []*Note{}
                for _, note := range notes </span><span class="cov0" title="0">{
                        if strings.HasPrefix(note.ID, identifier) </span><span class="cov0" title="0">{
                                matches = append(matches, note)
                        }</span>
                }

                <span class="cov0" title="0">if len(matches) == 1 </span><span class="cov0" title="0">{
                        targetNote = matches[0]
                }</span> else<span class="cov0" title="0"> if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("ambiguous ID '%s', could match: %s",
                                identifier,
                                func() string </span><span class="cov0" title="0">{
                                        var ids []string
                                        for _, n := range matches </span><span class="cov0" title="0">{
                                                ids = append(ids, n.ID)
                                        }</span>
                                        <span class="cov0" title="0">return strings.Join(ids, ", ")</span>
                                }())
                }
        }

        // If still not found, try partial title match
        <span class="cov0" title="0">if targetNote == nil </span><span class="cov0" title="0">{
                for _, note := range notes </span><span class="cov0" title="0">{
                        if strings.Contains(strings.ToLower(note.Title), strings.ToLower(identifier)) </span><span class="cov0" title="0">{
                                targetNote = note
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">if targetNote == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("note not found: %s", identifier)
        }</span>

        <span class="cov0" title="0">return openInEditor(targetNote.FilePath)</span>
}

// GetStats returns basic statistics about notes
func GetStats() (map[string]interface{}, error) <span class="cov0" title="0">{
        notes, err := ListNotes("", "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Count notes this week
        <span class="cov0" title="0">weekAgo := time.Now().AddDate(0, 0, -7)
        thisWeek := 0
        for _, note := range notes </span><span class="cov0" title="0">{
                if note.Date.After(weekAgo) </span><span class="cov0" title="0">{
                        thisWeek++
                }</span>
        }

        // Count tags
        <span class="cov0" title="0">tagCounts := make(map[string]int)
        for _, note := range notes </span><span class="cov0" title="0">{
                for _, tag := range note.Tags </span><span class="cov0" title="0">{
                        tagCounts[tag]++
                }</span>
        }

        <span class="cov0" title="0">stats := map[string]interface{}{
                "total_notes": len(notes),
                "this_week":   thisWeek,
                "tag_counts":  tagCounts,
        }

        return stats, nil</span>
}

// Helper functions

func generateShortID(filename string) string <span class="cov0" title="0">{
        // Generate a short hash from the filename for a git-like ID
        h := sha1.New()
        h.Write([]byte(filename))
        hash := fmt.Sprintf("%x", h.Sum(nil))
        // Return first 7 characters like git
        return hash[:7]
}</span>

func slugify(text string) string <span class="cov0" title="0">{
        // Convert to lowercase and replace spaces/special chars with hyphens
        reg := regexp.MustCompile(`[^a-zA-Z0-9]+`)
        slug := reg.ReplaceAllString(strings.ToLower(text), "-")
        return strings.Trim(slug, "-")
}</span>

func generateNoteContent(note *Note) string <span class="cov0" title="0">{
        tagsStr := ""
        if len(note.Tags) &gt; 0 </span><span class="cov0" title="0">{
                tagsStr = fmt.Sprintf("[%s]", strings.Join(note.Tags, ", "))
        }</span> else<span class="cov0" title="0"> {
                tagsStr = "[]"
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(`---
title: %s
tags: %s
mode: %s
date: %s
---

`,
                note.Title,
                tagsStr,
                note.Mode,
                note.Date.Format(time.RFC3339),
        )</span>
}

func parseNoteFile(filePath string) (*Note, error) <span class="cov0" title="0">{
        content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">contentStr := string(content)

        // Generate short hash ID from filename
        filename := filepath.Base(filePath)
        id := generateShortID(filename)

        // Parse metadata from content
        lines := strings.Split(contentStr, "\n")
        note := &amp;Note{
                ID:       id,
                FilePath: filePath,
                Content:  contentStr,
        }

        // Simple metadata parsing
        inMetadata := false
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "---" </span><span class="cov0" title="0">{
                        if !inMetadata </span><span class="cov0" title="0">{
                                inMetadata = true
                                continue</span>
                        } else<span class="cov0" title="0"> {
                                break</span>
                        }
                }

                <span class="cov0" title="0">if inMetadata </span><span class="cov0" title="0">{
                        if strings.HasPrefix(line, "title:") </span><span class="cov0" title="0">{
                                note.Title = strings.TrimSpace(strings.TrimPrefix(line, "title:"))
                                note.Title = strings.Trim(note.Title, "\"")
                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(line, "mode:") </span><span class="cov0" title="0">{
                                note.Mode = strings.TrimSpace(strings.TrimPrefix(line, "mode:"))
                                note.Mode = strings.Trim(note.Mode, "\"")
                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(line, "date:") </span><span class="cov0" title="0">{
                                dateStr := strings.TrimSpace(strings.TrimPrefix(line, "date:"))
                                dateStr = strings.Trim(dateStr, "\"")
                                if date, err := time.Parse(time.RFC3339, dateStr); err == nil </span><span class="cov0" title="0">{
                                        note.Date = date
                                }</span>
                        } else<span class="cov0" title="0"> if strings.HasPrefix(line, "tags:") </span><span class="cov0" title="0">{
                                tagsStr := strings.TrimSpace(strings.TrimPrefix(line, "tags:"))
                                tagsStr = strings.Trim(tagsStr, "[]")
                                if tagsStr != "" </span><span class="cov0" title="0">{
                                        tags := strings.Split(tagsStr, ",")
                                        for i, tag := range tags </span><span class="cov0" title="0">{
                                                tags[i] = strings.TrimSpace(tag)
                                        }</span>
                                        <span class="cov0" title="0">note.Tags = tags</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return note, nil</span>
}

func openInEditor(filePath string) error <span class="cov0" title="0">{
        editor := config.AppConfig.Editor
        cmd := exec.Command(editor, filePath)
        cmd.Stdin = os.Stdin
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        return cmd.Run()
}</span>

func contains(slice []string, item string) bool <span class="cov0" title="0">{
        for _, s := range slice </span><span class="cov0" title="0">{
                if s == item </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package service

import (
        "crypto/sha1"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "strings"
        "time"

        "github.com/sk25469/jot/config"
        "github.com/sk25469/jot/database"
        "github.com/sk25469/jot/models"
)

// NoteService handles business logic for notes
type NoteService struct {
        noteRepo  *database.NoteRepository
        statsRepo *database.StatsRepository
}

// NewNoteService creates a new note service
func NewNoteService(db *database.DB) *NoteService <span class="cov0" title="0">{
        return &amp;NoteService{
                noteRepo:  database.NewNoteRepository(db),
                statsRepo: database.NewStatsRepository(db),
        }
}</span>

// CreateNote creates a new note with the given title and options
func (s *NoteService) CreateNote(title string, tags []string, mode string) (*models.Note, error) <span class="cov0" title="0">{
        if mode == "" </span><span class="cov0" title="0">{
                mode = config.AppConfig.DefaultMode
        }</span>

        // Generate timestamp-based filename
        <span class="cov0" title="0">timestamp := time.Now().UTC().Format("2006-01-02T15-04-05Z")
        slug := slugify(title)
        filename := fmt.Sprintf("%s-%s.md", timestamp, slug)

        notesDir := config.GetNotesDir()
        filePath := filepath.Join(notesDir, filename)

        // Generate short hash ID from filename
        id := generateShortID(filename)

        // Create note model
        note := &amp;models.Note{
                ID:        id,
                Title:     title,
                Mode:      mode,
                FilePath:  filePath,
                FileName:  filename,
                CreatedAt: time.Now().UTC(),
                UpdatedAt: time.Now().UTC(),
                Tags:      tags,
        }

        // Create note content with metadata header
        content := s.generateNoteContent(note)
        note.ContentHash = s.generateContentHash(content)
        note.ContentPreview = s.generatePreview(content)
        note.WordCount = s.countWords(content)

        // Write file
        if err := os.WriteFile(filePath, []byte(content), 0644); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write note file: %w", err)
        }</span>

        // Save to database
        <span class="cov0" title="0">if err := s.noteRepo.Create(note); err != nil </span><span class="cov0" title="0">{
                // Clean up file if database save fails
                os.Remove(filePath)
                return nil, fmt.Errorf("failed to save note to database: %w", err)
        }</span>

        // Update FTS index
        <span class="cov0" title="0">if err := s.updateFTSIndex(note, content); err != nil </span><span class="cov0" title="0">{
                // Log warning but don't fail - FTS is optional
                fmt.Printf("Warning: failed to update FTS index: %v\n", err)
        }</span>

        // Open in editor
        <span class="cov0" title="0">if err := s.openInEditor(filePath); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open editor: %w", err)
        }</span>

        <span class="cov0" title="0">return note, nil</span>
}

// ListNotes returns notes with optional filtering
func (s *NoteService) ListNotes(tagFilter, modeFilter string) ([]*models.Note, error) <span class="cov0" title="0">{
        filter := models.DefaultListFilter()

        if tagFilter != "" </span><span class="cov0" title="0">{
                filter.Tags = []string{tagFilter}
        }</span>
        <span class="cov0" title="0">if modeFilter != "" </span><span class="cov0" title="0">{
                filter.Mode = modeFilter
        }</span>

        <span class="cov0" title="0">return s.noteRepo.List(filter)</span>
}

// SearchNotes searches for notes by query string
func (s *NoteService) SearchNotes(query string) ([]*models.SearchResult, error) <span class="cov0" title="0">{
        return s.noteRepo.Search(query)
}</span>

// OpenNote opens a note by ID or title
func (s *NoteService) OpenNote(identifier string) error <span class="cov0" title="0">{
        // Try to find by exact ID first
        note, err := s.noteRepo.GetByID(identifier)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("database error: %w", err)
        }</span>

        // If not found by exact ID, try partial ID match
        <span class="cov0" title="0">if note == nil </span><span class="cov0" title="0">{
                notes, err := s.ListNotes("", "")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to list notes for partial search: %w", err)
                }</span>

                <span class="cov0" title="0">var matches []*models.Note
                for _, n := range notes </span><span class="cov0" title="0">{
                        if strings.HasPrefix(n.ID, identifier) </span><span class="cov0" title="0">{
                                matches = append(matches, n)
                        }</span>
                }

                <span class="cov0" title="0">if len(matches) == 1 </span><span class="cov0" title="0">{
                        note = matches[0]
                }</span> else<span class="cov0" title="0"> if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        var ids []string
                        for _, n := range matches </span><span class="cov0" title="0">{
                                ids = append(ids, n.ID)
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("ambiguous ID '%s', could match: %s",
                                identifier, strings.Join(ids, ", "))</span>
                }
        }

        // If still not found, try partial title match
        <span class="cov0" title="0">if note == nil </span><span class="cov0" title="0">{
                notes, err := s.ListNotes("", "")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to list notes for title search: %w", err)
                }</span>

                <span class="cov0" title="0">for _, n := range notes </span><span class="cov0" title="0">{
                        if strings.Contains(strings.ToLower(n.Title), strings.ToLower(identifier)) </span><span class="cov0" title="0">{
                                note = n
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">if note == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("note not found: %s", identifier)
        }</span>

        <span class="cov0" title="0">return s.openInEditor(note.FilePath)</span>
}

// GetStats returns statistics about notes
func (s *NoteService) GetStats() (*models.StatsResult, error) <span class="cov0" title="0">{
        return s.statsRepo.GetStats()
}</span>

// SyncFromFileSystem scans the notes directory and syncs with database
func (s *NoteService) SyncFromFileSystem() error <span class="cov0" title="0">{
        notesDir := config.GetNotesDir()

        files, err := filepath.Glob(filepath.Join(notesDir, "*.md"))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to scan notes directory: %w", err)
        }</span>

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                if err := s.syncNoteFromFile(file); err != nil </span><span class="cov0" title="0">{
                        // Log error but continue with other files
                        fmt.Printf("Warning: failed to sync %s: %v\n", file, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Helper functions

func (s *NoteService) syncNoteFromFile(filePath string) error <span class="cov0" title="0">{
        content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read file: %w", err)
        }</span>

        <span class="cov0" title="0">filename := filepath.Base(filePath)
        id := generateShortID(filename)

        // Check if note exists in database
        existingNote, err := s.noteRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check existing note: %w", err)
        }</span>

        // Parse note from file content
        <span class="cov0" title="0">note, err := s.parseNoteFile(filePath, string(content))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse note file: %w", err)
        }</span>

        <span class="cov0" title="0">if existingNote == nil </span><span class="cov0" title="0">{
                // Create new note in database
                if err := s.noteRepo.Create(note); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // Update FTS index
                <span class="cov0" title="0">return s.updateFTSIndex(note, string(content))</span>
        } else<span class="cov0" title="0"> {
                // Update if content changed
                newHash := s.generateContentHash(string(content))
                if existingNote.ContentHash != newHash </span><span class="cov0" title="0">{
                        note.ID = existingNote.ID               // Preserve ID
                        note.CreatedAt = existingNote.CreatedAt // Preserve creation time
                        note.ContentHash = newHash
                        if err := s.noteRepo.Update(note); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // Update FTS index
                        <span class="cov0" title="0">return s.updateFTSIndex(note, string(content))</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *NoteService) parseNoteFile(filePath, content string) (*models.Note, error) <span class="cov0" title="0">{
        filename := filepath.Base(filePath)
        id := generateShortID(filename)

        note := &amp;models.Note{
                ID:             id,
                FilePath:       filePath,
                FileName:       filename,
                ContentHash:    s.generateContentHash(content),
                ContentPreview: s.generatePreview(content),
                WordCount:      s.countWords(content),
                UpdatedAt:      time.Now().UTC(),
        }

        // Parse metadata from content
        lines := strings.Split(content, "\n")
        inMetadata := false

        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "---" </span><span class="cov0" title="0">{
                        if !inMetadata </span><span class="cov0" title="0">{
                                inMetadata = true
                                continue</span>
                        } else<span class="cov0" title="0"> {
                                break</span>
                        }
                }

                <span class="cov0" title="0">if inMetadata </span><span class="cov0" title="0">{
                        if strings.HasPrefix(line, "title:") </span><span class="cov0" title="0">{
                                note.Title = strings.TrimSpace(strings.TrimPrefix(line, "title:"))
                                note.Title = strings.Trim(note.Title, "\"")
                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(line, "mode:") </span><span class="cov0" title="0">{
                                note.Mode = strings.TrimSpace(strings.TrimPrefix(line, "mode:"))
                                note.Mode = strings.Trim(note.Mode, "\"")
                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(line, "date:") </span><span class="cov0" title="0">{
                                dateStr := strings.TrimSpace(strings.TrimPrefix(line, "date:"))
                                dateStr = strings.Trim(dateStr, "\"")
                                if date, err := time.Parse(time.RFC3339, dateStr); err == nil </span><span class="cov0" title="0">{
                                        note.CreatedAt = date
                                }</span>
                        } else<span class="cov0" title="0"> if strings.HasPrefix(line, "tags:") </span><span class="cov0" title="0">{
                                tagsStr := strings.TrimSpace(strings.TrimPrefix(line, "tags:"))
                                tagsStr = strings.Trim(tagsStr, "[]")
                                if tagsStr != "" </span><span class="cov0" title="0">{
                                        tags := strings.Split(tagsStr, ",")
                                        for i, tag := range tags </span><span class="cov0" title="0">{
                                                tags[i] = strings.TrimSpace(tag)
                                        }</span>
                                        <span class="cov0" title="0">note.Tags = tags</span>
                                }
                        }
                }
        }

        // Set defaults if not found
        <span class="cov0" title="0">if note.Title == "" </span><span class="cov0" title="0">{
                note.Title = "Untitled"
        }</span>
        <span class="cov0" title="0">if note.Mode == "" </span><span class="cov0" title="0">{
                note.Mode = config.AppConfig.DefaultMode
        }</span>
        <span class="cov0" title="0">if note.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                note.CreatedAt = time.Now().UTC()
        }</span>

        <span class="cov0" title="0">return note, nil</span>
}

func generateShortID(filename string) string <span class="cov0" title="0">{
        h := sha1.New()
        h.Write([]byte(filename))
        hash := fmt.Sprintf("%x", h.Sum(nil))
        return hash[:7]
}</span>

func slugify(text string) string <span class="cov0" title="0">{
        reg := regexp.MustCompile(`[^a-zA-Z0-9]+`)
        slug := reg.ReplaceAllString(strings.ToLower(text), "-")
        return strings.Trim(slug, "-")
}</span>

func (s *NoteService) generateNoteContent(note *models.Note) string <span class="cov8" title="1">{
        tagsStr := ""
        if len(note.Tags) &gt; 0 </span><span class="cov8" title="1">{
                tagsStr = fmt.Sprintf("[%s]", strings.Join(note.Tags, ", "))
        }</span> else<span class="cov8" title="1"> {
                tagsStr = "[]"
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf(`---
title: %s
tags: %s
mode: %s
date: %s
---

`,
                note.Title,
                tagsStr,
                note.Mode,
                note.CreatedAt.Format(time.RFC3339),
        )</span>
}

func (s *NoteService) generateContentHash(content string) string <span class="cov8" title="1">{
        h := sha1.New()
        h.Write([]byte(content))
        return fmt.Sprintf("%x", h.Sum(nil))
}</span>

func (s *NoteService) generatePreview(content string) string <span class="cov8" title="1">{
        // Remove YAML frontmatter
        lines := strings.Split(content, "\n")
        inMetadata := false
        contentStart := 0

        for i, line := range lines </span><span class="cov8" title="1">{
                if strings.TrimSpace(line) == "---" </span><span class="cov8" title="1">{
                        if !inMetadata </span><span class="cov8" title="1">{
                                inMetadata = true
                        }</span> else<span class="cov8" title="1"> {
                                contentStart = i + 1
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if contentStart &lt; len(lines) </span><span class="cov8" title="1">{
                preview := strings.Join(lines[contentStart:], "\n")
                preview = strings.TrimSpace(preview)
                if len(preview) &gt; 200 </span><span class="cov8" title="1">{
                        return preview[:200]
                }</span>
                <span class="cov8" title="1">return preview</span>
        }

        <span class="cov8" title="1">return ""</span>
}

func (s *NoteService) countWords(content string) int <span class="cov8" title="1">{
        // Simple word count - split by whitespace
        words := strings.Fields(content)
        return len(words)
}</span>

func (s *NoteService) openInEditor(filePath string) error <span class="cov0" title="0">{
        // This is the same as the original openInEditor function
        editor := config.AppConfig.Editor
        cmd := exec.Command(editor, filePath)
        cmd.Stdin = os.Stdin
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        return cmd.Run()
}</span>

// updateFTSIndex updates the full-text search index for a note
func (s *NoteService) updateFTSIndex(note *models.Note, content string) error <span class="cov0" title="0">{
        // Get database connection
        db := s.noteRepo.GetDB()

        // Prepare tags string for FTS
        tagsStr := strings.Join(note.Tags, " ")

        // Insert or replace in FTS table
        query := `INSERT OR REPLACE INTO notes_fts (note_id, title, content, tags) VALUES (?, ?, ?, ?)`
        _, err := db.Connection().Exec(query, note.ID, note.Title, content, tagsStr)

        return err
}</span>

// deleteFTSIndex removes a note from the FTS index
func (s *NoteService) deleteFTSIndex(noteID string) error <span class="cov0" title="0">{
        // Get database connection
        db := s.noteRepo.GetDB()

        query := `DELETE FROM notes_fts WHERE note_id = ?`
        _, err := db.Connection().Exec(query, noteID)

        return err
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package styles

import (
        "crypto/sha1"
        "fmt"
        "math"

        "github.com/charmbracelet/lipgloss"
)

// Color palette
var (
        // Primary colors
        Primary   = lipgloss.Color("#00D4AA")
        Secondary = lipgloss.Color("#6B73FF")
        Accent    = lipgloss.Color("#FFB86C")

        // Status colors
        Success = lipgloss.Color("#50FA7B")
        Warning = lipgloss.Color("#F1FA8C")
        Error   = lipgloss.Color("#FF5555")

        // Neutral colors
        Subtle = lipgloss.Color("#6272A4")
        Muted  = lipgloss.Color("#44475A")
        Text   = lipgloss.Color("#F8F8F2")
)

// Base styles
var (
        // Title styles
        TitleStyle = lipgloss.NewStyle().
                        Bold(true).
                        Foreground(Primary).
                        MarginLeft(1).
                        MarginBottom(1)

        SubtitleStyle = lipgloss.NewStyle().
                        Foreground(Secondary).
                        Bold(true)

        // ID styles
        IDStyle = lipgloss.NewStyle().
                Foreground(Accent).
                Bold(true)

        // Date styles
        DateStyle = lipgloss.NewStyle().
                        Foreground(Subtle).
                        Italic(true)

        // Content styles
        ContentStyle = lipgloss.NewStyle().
                        Foreground(Text)

        PreviewStyle = lipgloss.NewStyle().
                        Foreground(Muted).
                        Italic(true).
                        MarginLeft(2)

        // List styles
        ListItemStyle = lipgloss.NewStyle().
                        PaddingLeft(2).
                        MarginBottom(1)

        ListHeaderStyle = lipgloss.NewStyle().
                        Bold(true).
                        Foreground(Primary).
                        BorderStyle(lipgloss.NormalBorder()).
                        BorderBottom(true).
                        BorderForeground(Primary).
                        MarginBottom(1).
                        PaddingBottom(1)

        // Stats styles
        StatsLabelStyle = lipgloss.NewStyle().
                        Bold(true).
                        Foreground(Secondary)

        StatsValueStyle = lipgloss.NewStyle().
                        Bold(true).
                        Foreground(Accent)

        // Search styles
        SearchQueryStyle = lipgloss.NewStyle().
                                Bold(true).
                                Foreground(Warning)

        SearchResultStyle = lipgloss.NewStyle().
                                MarginLeft(1).
                                PaddingLeft(1).
                                BorderStyle(lipgloss.NormalBorder()).
                                BorderLeft(true).
                                BorderForeground(Subtle)

        SnippetStyle = lipgloss.NewStyle().
                        Foreground(Muted).
                        Italic(true).
                        MarginLeft(4)

        // Error styles
        ErrorStyle = lipgloss.NewStyle().
                        Bold(true).
                        Foreground(Error).
                        Background(lipgloss.Color("#44475A")).
                        Padding(0, 1)

        WarningStyle = lipgloss.NewStyle().
                        Bold(true).
                        Foreground(Warning).
                        Background(lipgloss.Color("#44475A")).
                        Padding(0, 1)

        SuccessStyle = lipgloss.NewStyle().
                        Bold(true).
                        Foreground(Success).
                        Background(lipgloss.Color("#44475A")).
                        Padding(0, 1)
)

// Tag colors - deterministic based on tag name
var tagColors = []lipgloss.Color{
        lipgloss.Color("#FF79C6"), // Pink
        lipgloss.Color("#8BE9FD"), // Cyan
        lipgloss.Color("#50FA7B"), // Green
        lipgloss.Color("#FFB86C"), // Orange
        lipgloss.Color("#BD93F9"), // Purple
        lipgloss.Color("#F1FA8C"), // Yellow
        lipgloss.Color("#FF5555"), // Red
        lipgloss.Color("#6272A4"), // Blue
}

// GetTagStyle returns a consistent style for a tag based on its name
func GetTagStyle(tagName string) lipgloss.Style <span class="cov8" title="1">{
        // Hash the tag name to get consistent color
        h := sha1.New()
        h.Write([]byte(tagName))
        hash := h.Sum(nil)
        colorIndex := int(hash[0]) % len(tagColors)

        return lipgloss.NewStyle().
                Background(tagColors[colorIndex]).
                Foreground(lipgloss.Color("#282A36")). // Dark background for readability
                Bold(true).
                Padding(0, 1).
                MarginRight(1)
}</span>

// GetModeStyle returns a style for note modes
func GetModeStyle(mode string) lipgloss.Style <span class="cov8" title="1">{
        switch mode </span>{
        case "dev":<span class="cov8" title="1">
                return lipgloss.NewStyle().
                        Background(Primary).
                        Foreground(lipgloss.Color("#282A36")).
                        Bold(true).
                        Padding(0, 1)</span>
        case "journal":<span class="cov8" title="1">
                return lipgloss.NewStyle().
                        Background(Secondary).
                        Foreground(lipgloss.Color("#F8F8F2")).
                        Bold(true).
                        Padding(0, 1)</span>
        case "meeting":<span class="cov8" title="1">
                return lipgloss.NewStyle().
                        Background(Accent).
                        Foreground(lipgloss.Color("#282A36")).
                        Bold(true).
                        Padding(0, 1)</span>
        default:<span class="cov8" title="1">
                return lipgloss.NewStyle().
                        Background(Muted).
                        Foreground(Text).
                        Bold(true).
                        Padding(0, 1)</span>
        }
}

// Utility functions

// RenderTags renders a slice of tags with consistent colors
func RenderTags(tags []string) string <span class="cov8" title="1">{
        if len(tags) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">var rendered []string
        for _, tag := range tags </span><span class="cov8" title="1">{
                rendered = append(rendered, GetTagStyle(tag).Render(tag))
        }</span>

        <span class="cov8" title="1">return lipgloss.JoinHorizontal(lipgloss.Left, rendered...)</span>
}

// RenderHeader creates a styled header
func RenderHeader(title string) string <span class="cov8" title="1">{
        return TitleStyle.Render("📝 " + title)
}</span>

// RenderSeparator creates a visual separator
func RenderSeparator() string <span class="cov8" title="1">{
        return lipgloss.NewStyle().
                Foreground(Subtle).
                Render("────────────────────────────────────────")
}</span>

// RenderProgress creates a simple progress indicator
func RenderProgress(current, total int) string <span class="cov8" title="1">{
        if total == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">percentage := float64(current) / float64(total) * 100
        filled := int(math.Round(percentage / 10)) // 10 segments

        progress := ""
        for i := 0; i &lt; 10; i++ </span><span class="cov8" title="1">{
                if i &lt; filled </span><span class="cov8" title="1">{
                        progress += "█"
                }</span> else<span class="cov8" title="1"> {
                        progress += "░"
                }</span>
        }

        <span class="cov8" title="1">return lipgloss.NewStyle().
                Foreground(Primary).
                Render(fmt.Sprintf("[%s] %d/%d (%.1f%%)", progress, current, total, percentage))</span>
}

// RenderBox creates a bordered box around content
func RenderBox(title, content string) string <span class="cov8" title="1">{
        return lipgloss.NewStyle().
                BorderStyle(lipgloss.RoundedBorder()).
                BorderForeground(Primary).
                Padding(1, 2).
                Width(60).
                Render(
                        lipgloss.JoinVertical(
                                lipgloss.Left,
                                lipgloss.NewStyle().Bold(true).Foreground(Primary).Render(title),
                                "",
                                content,
                        ),
                )
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
